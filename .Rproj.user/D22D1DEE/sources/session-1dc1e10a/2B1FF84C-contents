// File: lpweights.cpp

#include <Rcpp.h>
using namespace Rcpp;

/*
  We compute local polynomial boundary weights for extracting the intercept 
at x=cutoff, side=left or right. 
Steps:
  1) Identify which observations actually matter (i.e. side_ok).
2) Build the design matrix (p+1 columns).
3) Accumulate X'WX and X'W. 
4) Invert X'WX by direct formula (2x2 or 3x3).
    5) Multiply to get the row for the intercept.

  We'll handle p=1 or p=2. 
  */
    
    // function that does a 2x2 inverse
  inline bool inv2(const double *M, double *Minv) {
    // M is row-major 2x2, M[0],M[1],M[2],M[3]
    double det = M[0]*M[3] - M[1]*M[2];
    if (std::fabs(det)<1e-14) {
      return false;
    }
    double invdet = 1.0/det;
    Minv[0] =  M[3]*invdet;
    Minv[1] = -M[1]*invdet;
    Minv[2] = -M[2]*invdet;
    Minv[3] =  M[0]*invdet;
    return true;
  }
  
  // function that does a 3x3 inverse in row-major order
  inline bool inv3(const double *M, double *Minv) {
    // We'll do a standard formula for 3x3.
  // M is 3x3 row-major: M[0..8]
  double det = 
    M[0]*(M[4]*M[8] - M[5]*M[7]) 
    - M[1]*(M[3]*M[8] - M[5]*M[6]) 
    + M[2]*(M[3]*M[7] - M[4]*M[6]);
  if(std::fabs(det)<1e-14) {
    return false;
  }
  double invdet = 1.0/det;
  
  Minv[0] = ( M[4]*M[8] - M[5]*M[7])*invdet;
  Minv[1] = ( M[2]*M[7] - M[1]*M[8])*invdet;
  Minv[2] = ( M[1]*M[5] - M[2]*M[4])*invdet;
  Minv[3] = ( M[5]*M[6] - M[3]*M[8])*invdet;
  Minv[4] = ( M[0]*M[8] - M[2]*M[6])*invdet;
  Minv[5] = ( M[2]*M[3] - M[0]*M[5])*invdet;
  Minv[6] = ( M[3]*M[7] - M[4]*M[6])*invdet;
  Minv[7] = ( M[1]*M[6] - M[0]*M[7])*invdet;
  Minv[8] = ( M[0]*M[4] - M[1]*M[3])*invdet;

  return true;
}

// [[Rcpp::export]]
NumericVector lpweights_rcpp(NumericVector X, double cutoff,
                             bool left_side, int p,
                             NumericVector kernvals,
                             double h) {
  // X: running variable
  // cutoff: threshold
  // left_side: side=TRUE => X<cutoff
  // p=1 or p=2
  // kernvals: kernel((X-cutoff)/h) * side indicator? 
  // h: bandwidth
  // Returns an n-vector of weights w_i.

  int n = X.size();
  int dim = p+1;  // 2 if p=1, 3 if p=2
  NumericVector wts(n, 0.0);

  // We'll accumulate XWX (dim x dim) row-major, plus XW (dim x n).
  std::vector<double> XWX(dim*dim, 0.0);
  std::vector<double> XW (dim*n, 0.0);
  
  for(int i=0; i<n; i++){
    bool side_ok = left_side ? (X[i]<cutoff) : (X[i]>=cutoff);
    double w_i = side_ok ? kernvals[i] : 0.0;
    if(w_i==0.0) continue;
    // build R[i,:]
    double u = (X[i] - cutoff)/h;
    double r0 = 1.0;
    double r1 = (p>=1 ? u : 0.0);
    double r2 = (p>=2 ? (u*u) : 0.0);
    
    double r[3]; // up to 3
    r[0] = r0; 
    r[1] = r1;
    r[2] = r2;
    
    // accumulate
    for(int a=0;a<dim;a++){
      for(int b=0;b<dim;b++){
        XWX[a*dim+b] += r[a]*r[b]* w_i;
      }
      // XW[a,i] 
      XW[a*n + i] += (r[a]* w_i);
    }
  }
  
  // invert XWX
  std::vector<double> invXWX(dim*dim, 0.0);
  bool ok = false;
  if(dim==2){
    ok = inv2(&XWX[0], &invXWX[0]);
  } else {
    ok = inv3(&XWX[0], &invXWX[0]);
  }
  if(!ok){
    // singular => return zero wts
    return wts;
  }
  
  // e0^T = (1,0,0,...)
  // alphaInv[j] = sum_k e0[k]*invXWX[k*dim + j] => that is just invXWX[0*dim + j] for j=0..dim-1
  // i.e. alphaInv is the first row of invXWX
  std::vector<double> alphaInv(dim, 0.0);
  for(int j=0;j<dim;j++){
    alphaInv[j] = invXWX[j]; // row=0 => index=0*dim + j => j
  }
  
  // w_i = alphaInv * XW(,i)
  // => sum_{j=0..dim-1} alphaInv[j]* XW[j*n + i]
  for(int i=0;i<n;i++){
    double sumv=0.0;
    for(int j=0;j<dim;j++){
      sumv += alphaInv[j]* XW[j*n + i];
    }
    wts[i]=sumv;
  }
  
  return wts;
  }
